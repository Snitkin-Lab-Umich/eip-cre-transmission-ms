---
title: "CRE EIP Manuscript Supplemental Figure 5 Figure"
author: "Kyle Gontjes"
date: "`r Sys.Date()`"
output: html_document
---

# Project: EIP CRE Manuscript

# Date: 06/13/23

# Author: Kyle Gontjes

# Purpose: Generate final figure with KPC-associated plasmid cluster sharing for isolates found in three states: Minnesota, Tennessee, and Connecticut

# Great Lakes Location:

### 1. Project Directory: /nfs/turbo/umms-esnitkin/Project_CRE_EIP/Analysis/Plasmid_analysis

### 2. Final Results Folder: 2023-06-13_CRE_EIP_final_manuscript_figure

# Notes:

### 1. Please note in the manuscript that this analysis evaluated the sharing of KPC-associated plasmid clusters, irrespective of the predicted location of the isolate pairs' KPC-containing contigs.

### 2. This was performed, instead of KPC-containing plasmid cluster sharing, because our use of short-read sequencing hinders our confidence in the specific location of the KPC-containing contig.

### 3. This caveat is important because nearly 60% of isolates had more than one KPC-associated plasmid cluster predicted via their short read assemblies. Therefore, two isolates could be classified as sharing a KPC-associated plasmid cluster, but each isolate's KPC-containing contig could be located on a different KPC-associated plasmid.

### 4. I talked w/ Evan and we agreed that we could keep the KPC-associated plasmid cluster analyses assuming that we are clear about our expectations and the limitations of the data.

```{r setup, include=FALSE}
require(knitr)
opts_knit$set(echo = TRUE,warning = FALSE, message = FALSE) 
opts_knit$set(root.dir='/Users/kyle/Desktop/gl_turbo/Project_CRE_EIP/Analysis/Plasmid_analysis/')
```

# Create Environment

```{r create environment,echo=T,include=T,results=T}
#Packages
packages <- c("tidyverse","cowplot","RColorBrewer","colorRamp2","grid","ComplexHeatmap")

#Load Packages
invisible(lapply(packages,library,character.only=T))
Sys.info()
sessionInfo()
```

# Load CRE EIP Metadata

### 1. I am working with the 2023-05_02_CRE_EIP_QC.csv generated by Ali. This includes Kleborate and Ariba ST data on all of our isolates.

```{r,include=T,echo=T,results=T,message=F,warning=F}
### Load Metadata ###
df <- readRDS("./data/CRE_EIP_metadata.RDS")

# Create State Variable 
df <- df %>% mutate(state = ifelse(grepl("MN",isolate_no),"MN", ifelse(grepl("TN",isolate_no),"TN","CT")))
```

# Species Recoding Notes:

### 1. We are using Kleborate calls for species (found in the variable, Kleborate_species).

### 2. I abbreviated the genus' and collapsed subspecies into their species.

### 3. For K. pneumoniae, we are using the Kleborate sequence type (ST) data (found in the variable, ST).

### 3. For Enterobacter species, we are using the E. cloacae ST data generated using Ariba and found in "Ecloacae.ST" variable.

### 4. Low-confidence ST calls were removed (i.e., "\*", "Novel", "ND", or "1LV")

```{r}
### Recode Species ###
# Abbreviating genus name and collapsing subspecies into their species.
df <- df %>% mutate(Kleborate_species =  dplyr::recode(Kleborate_species,
                                             `Citrobacter freundii"` =  "C. freundii",
                                             `Citrobacter portucalensis` =  "C. portucalensis",
                                             `Citrobacter werkmanii` =  "C. werkmanii",
                                             `Enterobacter asburiae` =  "E. asburiae",
                                             `Enterobacter cloacae` = "E. cloacae",
                                             `Enterobacter hormaechei` =  "E. hormaechei",
                                             `Enterobacter roggenkampii` =  "E. roggenkampii",
                                             `Escherichia coli / Shigella` =  "E. coli / Shigella",
                                             `Klebsiella aerogenes` =  "K. aerogenes",
                                             `Klebsiella michiganensis` =  "K. michiganensis",
                                             `Klebsiella oxytoca` =  "K. oxytoca",
                                             `Klebsiella pneumoniae` =  "K. pneumoniae",
                                             `Klebsiella quasipneumoniae subsp. quasipneumoniae` =  "K. quasipneumoniae",
                                             `Klebsiella quasipneumoniae subsp. similipneumoniae` =  "K. quasipneumoniae",
                                             `Klebsiella variicola subsp. variicola` =  "K. variicola",
                                             `Lelliottia nimipressuralis` =  "L. nimipressuralis",
                                             `Serratia marcescens` =  "S. marcescens"))

### Only keep K. pneumoniae & E. hormaechei isolates ###
df <- df %>% subset(Kleborate_species %in% c("K. pneumoniae","E. hormaechei"))

### Species/ST Recoding ###
# Removed K. pneumoniae isolates with 1LV or novel ST
KPN_isolates_to_remove <- df %>% subset(Kleborate_species == "K. pneumoniae") %>% subset(grepl("\\*",ST) == T | ST == "Novel" | ST =="ND" | grepl("1LV",ST) == T) %>% select(isolate_no) %>% unlist

# Removed E. hormaechei isolates with low confidence Ariba ST call
Enterobacter_isolates_to_remove <- df %>% subset(Kleborate_species == "E. hormaechei") %>%  subset(grepl("\\*",Ecloacae.ST) == T | Ecloacae.ST == "Novel" | Ecloacae.ST =="ND") %>% select(isolate_no) %>% unlist

# Remove the isolates
df <- df %>% subset(!isolate_no %in% c(KPN_isolates_to_remove,Enterobacter_isolates_to_remove))

### Add ST to K. pneumoniae and Enterobacter isolates ###
df <- df %>% mutate(ST_Kpn_Eh = ifelse(Kleborate_species == "K. pneumoniae",paste0("K. pneumoniae ",ST),
                                   ifelse(Kleborate_species %in% c("E. hormaechei"),paste0("E. hormaechei ST ",Ecloacae.ST),Kleborate_species)))
```

# Load Mob-Suite Data.

### 1. Mob_recon was run using default settings on the 2023-05-05 genome assemblies found in the project's Sequence_data/assembly/2023-05-05_assembly directory

### 2. blastn was run to identify KPC alleles found in the CARD database on our isolate assemblies

### 3. KPC-containing plasmids were identified by linking the KPC-containing plasmid to their location (i.e., chromosome or plasmid X)

```{r}
### Load KPC & Mobtyper Data ###
# Matrices
plasmid_cluster <- readRDS("./2023-05-09_mobsuite/results/CRE_EIP_mobtyper_plasmid_cluster_matrix_050923.RDS") 

# Mobtyper Contig Data
mobtyper_results_kpc <- readRDS("./2023-05-09_mobsuite/results/CRE_EIP_mobtyper_results_clean_KPC_050923.RDS") 

### KPC-Associated Plasmid Clusters ###
KPC_associated_plasmid_clusters <- subset(mobtyper_results_kpc,KPC_present==1) %>% select(primary_cluster_id) %>% unique %>% unlist(use.names = F)

KPC_associated_plasmid_cluster_matrix <- plasmid_cluster %>% select(all_of(KPC_associated_plasmid_clusters))

### Get KPC Containing Isolates ###
KPC_containing_isolates <- KPC_associated_plasmid_cluster_matrix %>% subset(rowSums(.)>0) %>% rownames %>% unlist
df <- df %>% subset(isolate_no %in% KPC_containing_isolates)
```

# Generate State-Specific Data

```{r,include=T,echo=F,results=T,message=F,warning=F}
### Get State-Specific Isolates ###
MN_isolates <- df %>% subset(state == "MN") %>% select(isolate_no) %>% unlist
TN_isolates <- df %>% subset(state == "TN") %>% select(isolate_no) %>% unlist
CT_isolates <- df %>% subset(state == "CT") %>% select(isolate_no) %>% unlist

### Get State-specific dataframe ###
MN_df <-  df %>% subset(state == "MN")
TN_df <-  df %>% subset(state == "TN")
CT_df <- df %>% subset(state == "CT") 

### State specific KPC-associated plasmid cluster matrices ###
MN_KPC_plasmid_cluster <- KPC_associated_plasmid_cluster_matrix %>%  subset(rownames(.) %in% MN_isolates) %>% select(any_of(KPC_associated_plasmid_clusters)) %>% select_if(colSums(.)>0)

TN_KPC_plasmid_cluster <- KPC_associated_plasmid_cluster_matrix %>% subset(rownames(.) %in% TN_isolates) %>% select(any_of(KPC_associated_plasmid_clusters)) %>% select_if(colSums(.)>0)

CT_KPC_plasmid_cluster <- KPC_associated_plasmid_cluster_matrix %>% subset(rownames(.) %in% CT_isolates) %>% select(any_of(KPC_associated_plasmid_clusters)) %>% select_if(colSums(.)>0)
```

# Algorithm to Characterize Plasmid Sharing Across Species/ST Boundaries

## Step 1. Create "Other" Sequence Type Categories

### 1. All sequence types with \<5 isolates were grouped into "other" categories

```{r}
### Create "other" sequence type categories for Kpn and Ehc ###
collapse_STs_under_5 <- function(df){
  
  Kpn_names_5 <- df %>% subset(Kleborate_species == "K. pneumoniae") %>% select(ST_Kpn_Eh) %>% table %>% ifelse(. >4,.,"Other K. pneumoniae STs") %>% ifelse(. != "Other K. pneumoniae STs",names(.),.)
  Eh_names_5 <- df %>% subset(Kleborate_species %in% c("E. hormaechei")) %>% select(ST_Kpn_Eh) %>% table %>%  ifelse(. >4,.,"Other E. hormaechei STs") %>% ifelse(. != "Other E. hormaechei STs",names(.),.)
  Renames_5 <- c(Kpn_names_5,Eh_names_5)

  updated_df <- df %>% mutate(Species_Kpn_Eh_ST_5 = dplyr::recode(ST_Kpn_Eh,!!!Renames_5)) 
  
  return(updated_df)
}
```

## Step 2. Calculate the Proportion of KPC-Associated Plasmid Sharing

### 1. The proportion of plasmid sharing across species/ST categories was calculated by dividing the number of isolate pairs across the two categories that share AT LEAST ONE KPC-associated plasmid cluster by the total number of isolate pairs across the two categories.

### 2. This is calculated irrespective of whether the isolate pairs both have KPC identified on the shared KPC-associated plasmid cluster(s).

```{r}
### Plasmid sharing algorithm ###
plasmid_sharing_algorithm <- function(dataset,species_variable,plasmid_matrix){
  
  ## Get total number of isolates per species
  isolates_per_species <- table(dataset[,species_variable]) %>% as.vector %>% `names<-`(names(table(dataset[,species_variable]))) 
  
  ## Total comparison count for species/ST boundary comparisons##
  total_comparison_count <- c()
  
  for(i in 1:length(isolates_per_species)){
   total_comparison_count[[i]] <- isolates_per_species[i]*isolates_per_species
  } %>% `names<-`(isolates_per_species)
  
  total_comparison_count <- do.call(cbind,total_comparison_count) %>% as.data.frame %>% `colnames<-`(names(isolates_per_species))
  
  ## Isolates and their species/ST data
  isolate_STs <- dataset %>% select(isolate_no,paste(species_variable))
  
  ## Function to get the number of plasmids shared
  get_number_of_plasmids_shared <- function(ST1,ST2,isolate_ST_dataset,plasmid_matrix){
    
  # ST1 Isolates Data
  ST1_isolates <- isolate_ST_dataset[isolate_ST_dataset[,paste(species_variable)] == ST1,]  %>% select(isolate_no) %>% unlist %>% `names<-`(NULL)
  ST1_plasmid_matrix <- plasmid_matrix %>% subset(rownames(.) %in% ST1_isolates) %>% subset(rowSums(.)>0) %>%  as.matrix
  
  # ST2 Isolates Data
  ST2_isolates <- isolate_ST_dataset[isolate_ST_dataset[,paste(species_variable)] == ST2,]  %>% select(isolate_no) %>% unlist %>% `names<-`(NULL)
  ST2_plasmid_matrix <- plasmid_matrix %>% subset(rownames(.) %in% ST2_isolates) %>% subset(rowSums(.)>0) %>%  as.matrix
  
  # Compare plasmid sharing of isolates  
  compare_ST1_to_ST2 <- apply(ST1_plasmid_matrix,MARGIN = 1,FUN=function(x){
      isolate_1 <- x %>% subset(.==1) %>% names(.) %>% unlist 
       
      sharing_sum_for_isolate_1 <- apply(ST2_plasmid_matrix,MARGIN = 1,FUN=function(y){
        isolate_2 <- y %>% subset(.==1) %>% names(.) %>% unlist 
        count <- ifelse(sum(isolate_1 %in% isolate_2)>0,1,0)
        return(count)
      }) %>% sum()
      return(sharing_sum_for_isolate_1)
  })
  
   pairs_sharing_plasmids_ST1_to_ST2 <- sum(compare_ST1_to_ST2)
   return(pairs_sharing_plasmids_ST1_to_ST2)
  }
  
  ## Calculate plasmid sharing
  plasmid_sharing <- c()
  
  for(i in 1:length(isolates_per_species)){
    plasmid_sharing[[i]] <- lapply(colnames(total_comparison_count),FUN=get_number_of_plasmids_shared,ST2=colnames(total_comparison_count)[i],isolate_ST_dataset = isolate_STs,plasmid_matrix = plasmid_matrix)
} %>% `names<-`(isolates_per_species)

  plasmid_sharing_matrix <- do.call(cbind,plasmid_sharing) %>% as.data.frame %>% `colnames<-`(names(isolates_per_species)) %>% `rownames<-`(names(isolates_per_species))
  
  ## Divide the plasmid sharing data by the total number of possible pairs
  proportion_plasmid_sharing_matrix <- c()
  for(i in 1:length(isolates_per_species)){
   proportion_plasmid_sharing_matrix[[i]] <- plasmid_sharing_matrix[i,]%>% as.vector %>% unlist / total_comparison_count[i,]%>% as.vector%>% unlist
  }
  proportion_plasmid_sharing_matrix <- do.call(cbind,proportion_plasmid_sharing_matrix) %>% as.data.frame %>% `colnames<-`(paste0(names(isolates_per_species)," (n=",isolates_per_species,")")) %>% `rownames<-`(paste0(names(isolates_per_species)," (n=",isolates_per_species,")"))
  
  return(proportion_plasmid_sharing_matrix)
}
```

## Step 3. Visualize the data using ComplexHeatmap

### 1. I initially tried to work with the pheatmap package. Unfortunately, it is not very customizable.

### 2. In response, I implemented the heatmap using ComplexHeatmap

-   ComplexHeatmap implemented pheatmap function in their package alongside many useful add-ons.

-   Thus, I kept the formatting provided by pheatmap, but altered the legend

### 3. Citation information for ComplexHeatmap:

-   Doi: <https://academic.oup.com/bioinformatics/article/32/18/2847/1743594>

-   Google Scholar Citation: Gu, Z., Eils, R. and Schlesner, M., 2016. Complex heatmaps reveal patterns and correlations in multidimensional genomic data. *Bioinformatics*, *32*(18), pp.2847-2849.

```{r}
### Create Heatmap for Plasmid Sharing ###
pheatmap_plasmid_sharing <- function(proportion_plasmid_sharing_matrix,title){
  figure <- ComplexHeatmap::pheatmap(proportion_plasmid_sharing_matrix %>% as.matrix,border_color = "black",name ="KPC-Associated Plasmid Sharing",legend=F,main =title,fontsize = 26,
    row_names_max_width = max_text_width(rownames(proportion_plasmid_sharing_matrix), gp = gpar(fontsize = 26)),
    column_names_max_height = max_text_width(rownames(proportion_plasmid_sharing_matrix), gp = gpar(fontsize = 26)),
    legend_breaks = c(0, .25, .5, .75, 1),legend_labels = c("0%", "25%", "50%", "75%", "100%"))
  return(figure)
}
```

# Create Individual Heatmaps for Each State

## A. Tennessee (TN)

```{r,fig.height=15.5,fig.width=14.33}
TN_df <- collapse_STs_under_5(TN_df)

plasmid_sharing_5_isolate_cutoff_TN <- plasmid_sharing_algorithm(TN_df,"Species_Kpn_Eh_ST_5",TN_KPC_plasmid_cluster)  
 
plasmid_sharing_5_isolate_cutoff_TN_heatmap <- pheatmap_plasmid_sharing(plasmid_sharing_5_isolate_cutoff_TN,title="Tennessee")

TN_heatmap_grob <- grid.grabExpr(draw(plasmid_sharing_5_isolate_cutoff_TN_heatmap,heatmap_legend_side = "bottom"))
```

## B. Minnesota (MN)

```{r,fig.height=15.5,fig.width=14.33}
MN_df <- collapse_STs_under_5(MN_df)

plasmid_sharing_5_isolate_cutoff_MN <- plasmid_sharing_algorithm(MN_df,"Species_Kpn_Eh_ST_5",MN_KPC_plasmid_cluster)  
 
plasmid_sharing_5_isolate_cutoff_MN_heatmap <- pheatmap_plasmid_sharing(plasmid_sharing_5_isolate_cutoff_MN,title="Minnesota")

MN_heatmap_grob <- grid.grabExpr(draw(plasmid_sharing_5_isolate_cutoff_MN_heatmap,heatmap_legend_side = "bottom"))
```

## C. Connecticut (CT)

```{r,fig.height=15.5,fig.width=14.33}
CT_df <- collapse_STs_under_5(CT_df)

plasmid_sharing_5_isolate_cutoff_CT <- plasmid_sharing_algorithm(CT_df,"Species_Kpn_Eh_ST_5",CT_KPC_plasmid_cluster)  
 
plasmid_sharing_5_isolate_cutoff_CT_heatmap <- pheatmap_plasmid_sharing(plasmid_sharing_5_isolate_cutoff_CT,title="Connecticut")

CT_heatmap_grob <- grid.grabExpr(draw(plasmid_sharing_5_isolate_cutoff_CT_heatmap,heatmap_legend_side = "bottom"))
```

# Plot & Save Figure With All Heatmaps for Publication

```{r,fig.height=18.6,fig.width=46.5}
### Plot Heatmaps Together ###
master_heatmap <- plot_grid(CT_heatmap_grob,MN_heatmap_grob,TN_heatmap_grob,ncol=3, axis="l", align="hv")

### Create Legend ###
one_hundred_breaks <- c()
for(i in 1:100){
  one_hundred_breaks[i] <- 0.01*i
} 

fig_legend <- Legend(at = c(0, .25, .5, .75, 1),labels = c("0%", "25%", "50%", "75%", "100%"),title = "KPC-Associated Plasmid Sharing",direction = "horizontal",col_fun = colorRamp2(breaks = one_hundred_breaks,colors = colorRampPalette(rev(brewer.pal(n = 7, name =  "RdYlBu")))(100)), title_gp = gpar(fontsize = 32, fontface = "bold"),labels_gp=gpar(fontsize=32),legend_width = unit(18, "cm"))

fig_legend_image <- grid.grabExpr(draw(fig_legend))

### Plot & Save Heatmap + Legend Plots ###
plasmid_sharing_heatmap_final <- plot_grid(master_heatmap,NULL,fig_legend_image,NULL,ncol=1,axis="l", align="hv",rel_heights = c(1,-.085,.25,-.085))

plasmid_sharing_heatmap_final

# PDF (Normal Size, w = 46.5; h = 18.6. This converts to w = 6.5; height = 2.6 in word)
ggsave("~/Desktop/gl_turbo/Project_CRE_EIP/Analysis/Plasmid_analysis/2023-06-13_CRE_EIP_final_manuscript_figure/results/CRE_EIP_manuscript_supplemental_figure_5_final_061323.pdf",width = 46.5,height = 18.6,dpi = 600)

# EPS
ggsave("~/Desktop/gl_turbo/Project_CRE_EIP/Analysis/Plasmid_analysis/2023-06-13_CRE_EIP_final_manuscript_figure/results/CRE_EIP_manuscript_supplemental_figure_5_final_061323.eps",width = 46.5,height = 18.6,dpi = 600)
```
